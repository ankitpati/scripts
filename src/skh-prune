#!/usr/bin/env perl
# Prune SSH Known Hosts

use strict;
use warnings;
use autodie;

use List::Util qw(uniq);

our $VERSION = 2.00;

# UTF8 for File Handles and Command Line Arguments
use open qw(:std :utf8);
use Encode qw(decode);
local @ARGV = map { decode 'UTF-8', $_ } @ARGV unless utf8::is_utf8 $ARGV[0];

# get filenames as arguments, or fallback to sensible defaults
@ARGV or local @ARGV = ("$ENV{HOME}/.ssh/known_hosts");

# precedence order (high to low) in case of multiple public keys for a host
my $precedence = 0;
my %algo_precedence = map { $_ => $precedence++ } qw(
    ssh-ed25519
    ecdsa-sha2-nistp521
    ecdsa-sha2-nistp256
    ssh-rsa
);

foreach my $skhfile (@ARGV) {
    open my $fin, '<', $skhfile;
    my @lines = <$fin>;
    close $fin;

    my %host_algo_key;
    foreach my $line (@lines) {
        my ($hosts, $algo, $key) = split /\s+/, $line; # comments are lost

        foreach my $host (split /,/, $hosts) {
            # unlisted algos get a random non-conflicting precedence
            $algo_precedence{$algo} = $precedence++
                unless exists $algo_precedence{$algo};

            $host_algo_key{$host} = [$algo, $key]
                if not exists $host_algo_key{$host} or
                    $algo_precedence{ $algo } <
                    $algo_precedence{ $host_algo_key{$host}[0] };
        }
    }

    my %algokey_hosts;
    while (my ($host, $algo_key) = each %host_algo_key) {
        local $" = ' ';
        push @{ $algokey_hosts{"@$algo_key"} }, $host;
    }

    my @known_hosts =
        map { ( join ',', sort &uniq (@{$algokey_hosts{$_}}) ) . " $_" }
            sort keys %algokey_hosts;

    open my $fout, '>', $skhfile;
    print $fout (join ("\n", @known_hosts), "\n");
    close $fout;
}

__END__
