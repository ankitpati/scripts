#!/usr/bin/env bash

set -euo pipefail

me="$(basename "$0")"
usage="Usage: $me <username[:groupname]> <path>... -- [bash arguments]"

test "$#" -lt 3 && echo "$usage" && exit 1

for arg in "$@"; do test '--' = "$arg" && break; done
test '--' != "$arg" && echo "$usage" && exit 2

user_group="$1"
shift # remove username:groupname

while test '--' != "$1"
do
    chown "$user_group" -hR "$1" || exit 3 # die immediately upon failure
    shift # remove paths we have dealt with
done
shift # remove '--'

username="${user_group/%:*/}" # no sed because it may not be installed

mapfile -t env2exp < <(compgen -e | grep -Ev "^(HISTCONTROL|HISTSIZE|HOME|\
HOSTNAME|LANG|LD_LIBRARY_PATH|LESSOPEN|LOGNAME|LS_COLORS|MAIL|OLDPWD|PATH|\
SHELL|SHLVL|TERM|USER)\$")

for env_key in "${env2exp[@]}"
do
    env4sudo=("${env4sudo[@]}" "$env_key=${!env_key}")
done

# `sudo`, if available, is always the better option: it does not call a shell
test -n "$(command -v sudo 2>/dev/null || :)" && \
    exec sudo -u "$username" "${env4sudo[@]}" -- "$@"

# the following runs iff `sudo` is not available
for env_key in "${env2exp[@]}"
do
    env4bashrc="$env4bashrc$(printf 'export %s=%q\n' "$env_key" "${!env_key}")"
done

userhome="$(getent passwd "$username" | cut -d':' -f6)"
echo "$env4bashrc" >> "$userhome/.bashrc"

# `su` is a fallback; calls the login shell of the specified user
exec su - "$username" -- "$@"
