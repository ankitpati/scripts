#!/usr/bin/env bash

# A customized Bash environment suitable for Git work.
#
# Copyright (c) 2008 Ryan Tomayko <http://tomayko.com/>
# Copyright (c) 2008 Aristotle Pagaltzis <http://plasmasturm.org/>
# Copyright (c) 2023 Ankit Pati <https://ankitpati.in/>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
# Distributed under the GNU General Public License, version 2.0.

if ! command -v __git_complete &>/dev/null
then
    _comp_load -D -- git
fi

function gitsh_complete {
    local -r alias=$1
    local -r subcommand=$2

    __git_complete "$alias" "_git_${subcommand//-/_}"
}

function gitsh_alias {
    local -r alias=$1
    local -r subcommand=$2
    local -r prog=${subcommand%% *}

    alias "$alias"="git $subcommand"
    gitsh_complete "$alias" "$prog"
}

gitsh_alias a       'add'
gitsh_alias aa      'add --update'
gitsh_alias amend   'commit --verbose --amend'
gitsh_alias ap      'add --patch'
gitsh_alias b       'branch'
gitsh_alias c       'checkout'
gitsh_alias ca      'commit --verbose --all'
gitsh_alias ci      'commit --verbose'
gitsh_alias d       'diff'
gitsh_alias ds      'diff --stat'
gitsh_alias f       'fetch --prune'
gitsh_alias f       'fetch'
gitsh_alias hard    'reset --hard'
gitsh_alias k       'cherry-pick'
gitsh_alias l       'log --pretty=oneline --abbrev-commit'
gitsh_alias n       'commit --verbose --amend'
gitsh_alias p       'diff --cached'
gitsh_alias peek    'log --patch --max-count=1'
gitsh_alias pm      'pull'
gitsh_alias pop     'reset --soft HEAD^'
gitsh_alias pr      'pull --rebase'
gitsh_alias r       'remote'
gitsh_alias re      'rebase --interactive'
gitsh_alias s       'commit --dry-run --short'
gitsh_alias scrap   'checkout HEAD'
gitsh_alias soft    'reset --soft'
gitsh_alias stage   'add'
gitsh_alias t       'diff --cached'
gitsh_alias unstage 'reset HEAD'
gitsh_alias wt      'worktree'

unset -f gitsh_alias

function gitsh_load_completions {
    local -rA completion_configs=(
        [add]='a'
        [am]='as'
        [annotate]='a'
        [apply]='as'
        [archive]='a'
        [bisect]='as'
        [blame]='a'
        [branch]='as'
        [bundle]='s'
        [cat-file]='a'
        [checkout]='as'
        [check-ignore]='a'
        [cherry-pick]='as'
        [clean]='a'
        [clone]='a'
        [commit]='as'
        [config]='as'
        [describe]='as'
        [diff]='as'
        [difftool]='a'
        [fetch]='as'
        [flow]='a'
        [format-patch]='as'
        [fsck]='a'
        [gui]='a'
        [hash-object]='a'
        [init]='a'
        [instaweb]='a'
        [log]='al'
        [lost-found]='a'
        [ls-files]='a'
        [ls-remote]='as'
        [ls-tree]='as'
        [merge]='as'
        [merge-base]='as'
        [mergetool]='a'
        [patch-id]='a'
        [peek-remote]='a'
        [prune]='a'
        [pull]='as'
        [push]='as'
        [quiltimport]='a'
        [rebase]='as'
        [reflog]='a'
        [remote]='as'
        [repack]='a'
        [repo-config]='a'
        [request-pull]='a'
        [reset]='as'
        [restore]='a'
        [rev-list]='a'
        [rev-parse]='a'
        [revert]='a'
        [send-email]='a'
        [send-pack]='a'
        [shortlog]='as'
        [show]='as'
        [show-branch]='al'
        [stash]='as'
        [status]='a'
        [stripspace]='a'
        [submodule]='as'
        [svn]='as'
        [symbolic-ref]='a'
        [switch]='a'
        [tag]='as'
        [tar-tree]='a'
        [var]='a'
        [whatchanged]='al'
        [worktree]='as'
    )

    local subcommand
    for subcommand in "${!completion_configs[@]}"
    do
        local completion_config=${completion_configs[$subcommand]}

        local completion_index
        for (( completion_index=0; completion_index < ${#completion_config}; ++completion_index ))
        do
            local completion_type=${completion_config:completion_index:1}
            case $completion_type in
                a)
                    # alias
                    alias "$subcommand"="git $subcommand"
                    ;;
                s)
                    # standard completion
                    __git_complete "$subcommand" "_git_${subcommand//-/_}"
                    ;;
                l)
                    # log completion
                    __git_complete "$subcommand" _git_log
                    ;;
            esac
        done
    done
}

gitsh_load_completions
unset -f gitsh_load_completions

function gitsh_headname {
    local headname=$(git symbolic-ref --quiet HEAD 2>/dev/null)

    if [[ -n $headname ]]
    then
        headname=${headname#refs/heads/}
    else
        headname=$(git rev-parse --short HEAD 2>/dev/null)
    fi

    gitsh_apply_color "$headname" 'yellow reverse'
}

function gitsh_upstream_state {
    # find how many commits we are ahead/behind our upstream
    local count=$(git rev-list --count --left-right '@{upstream}'...HEAD 2>/dev/null)
    count=${count//$'\t'/ }

    local upstream_state
    case "$count" in
        '')
            # no upstream
            upstream_state=''
            ;;
        '0 0')
            # equal to upstream
            upstream_state=' u='
            ;;
        '0 '*)
            # ahead of upstream
            upstream_state=" u+${count#0 }"
            ;;
        *' 0')
            # behind upstream
            upstream_state=" u-${count% 0}"
            ;;
        *)
            # diverged from upstream
            upstream_state=" u+${count#* }-${count% *}"
            ;;
    esac

    gitsh_apply_color "$upstream_state" 'yellow bold'
}

function gitsh_repo_state {
    local state_marker
    local -r git_dir=$(git rev-parse --git-dir 2>/dev/null)

    if [[ -d $git_dir/rebase-merge || -d $git_dir/rebase-apply ]]
    then
        state_marker='(rebase)'
    elif [[ -f $git_dir/MERGE_HEAD ]]
    then
        state_marker='(merge)'
    elif [[ -f $git_dir/CHERRY_PICK_HEAD ]]
    then
        state_marker='(cherry-pick)'
    else
        return 0
    fi

    gitsh_apply_color "$state_marker" red
}

function gitsh_workdir {
    local subdir=$(git rev-parse --show-prefix 2>/dev/null)
    subdir=${subdir%/}

    local workdir=${PWD%/"$subdir"}
    workdir="${workdir/*\/}${subdir:+/$subdir}"

    gitsh_apply_color "$workdir" 'blue bold'
}

function gitsh_dirty {
    if ! git rev-parse --verify HEAD >/dev/null 2>&1
    then
        return 0
    fi

    local -r dirty_marker=' *'

    if ! git diff --quiet 2>/dev/null
    then
        gitsh_apply_color "$dirty_marker" red
    elif ! git diff --staged --quiet 2>/dev/null
    then
        gitsh_apply_color "$dirty_marker" yellow
    else
        return 0
    fi
}

function gitsh_dirty_stash {
    if ! git rev-parse --verify refs/stash >/dev/null 2>&1
    then
        return 0
    fi

    local -r dirty_stash_marker=' $'

    gitsh_apply_color "$dirty_stash_marker" red
}

readonly -A gitsh_colors=(
    [blue bold]=$'\e[1;34m'
    [red]=$'\e[31m'
    [yellow bold]=$'\e[1;33m'
    [yellow reverse]=$'\e[7;33m'
    [yellow]=$'\e[33m'
)

function gitsh_apply_color {
    local -r ansi_reset=$'\001\e[m\002'

    local -r output=$1
    local color=$2

    color="\001${gitsh_colors[$color]}\002"

    echo -ne "${color}${output}${ansi_reset}"
}

function gitsh_prompt {
    gitsh_headname
    gitsh_upstream_state
    printf '!'
    gitsh_repo_state
    gitsh_workdir
    gitsh_dirty
    gitsh_dirty_stash
}

PS1='$(gitsh_prompt)> '

# This is referenced in `~/.bashrc`.
# shellcheck disable=2034
ADD_ON_PS1=$PS1
