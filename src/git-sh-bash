#!/usr/bin/env bash

# A customized Bash environment suitable for Git work.
#
# Copyright (c) 2008 Ryan Tomayko <http://tomayko.com/>
# Copyright (c) 2008 Aristotle Pagaltzis <http://plasmasturm.org/>
# Copyright (c) 2023 Ankit Pati <https://ankitpati.in/>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
# Distributed under the GNU General Public License, version 2.0.

if ! command -v __git_complete &>/dev/null
then
    _comp_load -D -- git
fi

function gitsh_complete {
    local alias=$1
    local command=$2

    __git_complete "$alias" "_git_${command//-/_}"
}

function gitsh_alias {
    local alias=$1
    local command=$2
    local prog=${command%% *}

    alias "$alias"="git $command"
    gitsh_complete "$alias" "$prog"
}

gitsh_alias a       'add'
gitsh_alias aa      'add --update'
gitsh_alias amend   'commit --verbose --amend'
gitsh_alias ap      'add --patch'
gitsh_alias b       'branch'
gitsh_alias c       'checkout'
gitsh_alias ca      'commit --verbose --all'
gitsh_alias ci      'commit --verbose'
gitsh_alias d       'diff'
gitsh_alias ds      'diff --stat'
gitsh_alias f       'fetch --prune'
gitsh_alias f       'fetch'
gitsh_alias hard    'reset --hard'
gitsh_alias k       'cherry-pick'
gitsh_alias l       'log --pretty=oneline --abbrev-commit'
gitsh_alias n       'commit --verbose --amend'
gitsh_alias p       'diff --cached'
gitsh_alias peek    'log --patch --max-count=1'
gitsh_alias pm      'pull'
gitsh_alias pop     'reset --soft HEAD^'
gitsh_alias pr      'pull --rebase'
gitsh_alias r       'remote'
gitsh_alias re      'rebase --interactive'
gitsh_alias s       'commit --dry-run --short'
gitsh_alias scrap   'checkout HEAD'
gitsh_alias soft    'reset --soft'
gitsh_alias stage   'add'
gitsh_alias t       'diff --cached'
gitsh_alias unstage 'reset HEAD'
gitsh_alias wt      'worktree'

unset -f gitsh_alias

function gitsh_load_completions {
    local git_cmd_cfg=(
        'add            alias'
        'am             alias  stdcmpl'
        'annotate       alias'
        'apply          alias  stdcmpl'
        'archive        alias'
        'bisect         alias  stdcmpl'
        'blame          alias'
        'branch         alias  stdcmpl'
        'bundle                stdcmpl'
        'cat-file       alias'
        'checkout       alias  stdcmpl'
        'check-ignore   alias'
        'cherry-pick    alias  stdcmpl'
        'clean          alias'
        'clone          alias'
        'commit         alias  stdcmpl'
        'config         alias  stdcmpl'
        'describe       alias  stdcmpl'
        'diff           alias  stdcmpl'
        'difftool       alias'
        'fetch          alias  stdcmpl'
        'flow           alias'
        'format-patch   alias  stdcmpl'
        'fsck           alias'
        'gui            alias'
        'hash-object    alias'
        'init           alias'
        'instaweb       alias'
        'log            alias  logcmpl'
        'lost-found     alias'
        'ls-files       alias'
        'ls-remote      alias  stdcmpl'
        'ls-tree        alias  stdcmpl'
        'merge          alias  stdcmpl'
        'merge-base     alias  stdcmpl'
        'mergetool      alias'
        'patch-id       alias'
        'peek-remote    alias'
        'prune          alias'
        'pull           alias  stdcmpl'
        'push           alias  stdcmpl'
        'quiltimport    alias'
        'rebase         alias  stdcmpl'
        'reflog         alias'
        'remote         alias  stdcmpl'
        'repack         alias'
        'repo-config    alias'
        'request-pull   alias'
        'reset          alias  stdcmpl'
        'restore        alias'
        'rev-list       alias'
        'rev-parse      alias'
        'revert         alias'
        'send-email     alias'
        'send-pack      alias'
        'shortlog       alias  stdcmpl'
        'show           alias  stdcmpl'
        'show-branch    alias  logcmpl'
        'stash          alias  stdcmpl'
        'status         alias'
        'stripspace     alias'
        'submodule      alias  stdcmpl'
        'svn            alias  stdcmpl'
        'symbolic-ref   alias'
        'switch         alias'
        'tag            alias  stdcmpl'
        'tar-tree       alias'
        'var            alias'
        'whatchanged    alias  logcmpl'
        'worktree       alias  stdcmpl'
    )

    local cfg
    for cfg in "${git_cmd_cfg[@]}" ; do
        local cmd
        local opts

        read -r cmd opts <<< $cfg

        local opt
        for opt in $opts ; do
            case $opt in
                alias)
                    alias "$cmd"="git $cmd"
                    ;;
                stdcmpl)
                    __git_complete "$cmd" "_git_${cmd//-/_}"
                    ;;
                logcmpl)
                    __git_complete "$cmd" _git_log
                    ;;
            esac
        done
    done
}

gitsh_load_completions
unset -f gitsh_load_completions

function gitsh_headname {
    local headname=$(git symbolic-ref --quiet HEAD 2>/dev/null)

    if [[ -n $headname ]]
    then
        headname=${headname#refs/heads/}
    else
        headname=$(git rev-parse --short HEAD 2>/dev/null)
    fi

    gitsh_apply_color "$headname" 'yellow reverse'
}

function gitsh_upstream_state {
    # find how many commits we are ahead/behind our upstream
    local count=$(git rev-list --count --left-right '@{upstream}'...HEAD 2>/dev/null)
    count=${count//$'\t'/ }

    local upstream_state
    case "$count" in
        '')
            # no upstream
            upstream_state=''
            ;;
        '0 0')
            # equal to upstream
            upstream_state=' u='
            ;;
        '0 '*)
            # ahead of upstream
            upstream_state=" u+${count#0 }"
            ;;
        *' 0')
            # behind upstream
            upstream_state=" u-${count% 0}"
            ;;
        *)
            # diverged from upstream
            upstream_state=" u+${count#* }-${count% *}"
            ;;
    esac

    gitsh_apply_color "$upstream_state" 'yellow bold'
}

function gitsh_repo_state {
    local state_marker
    local git_dir=$(git rev-parse --git-dir 2>/dev/null)

    if [[ -d $git_dir/rebase-merge || -d $git_dir/rebase-apply ]]
    then
        state_marker='(rebase)'
    elif [[ -f $git_dir/MERGE_HEAD ]]
    then
        state_marker='(merge)'
    elif [[ -f $git_dir/CHERRY_PICK_HEAD ]]
    then
        state_marker='(cherry-pick)'
    else
        return 0
    fi

    gitsh_apply_color "$state_marker" red
}

function gitsh_workdir {
    local subdir=$(git rev-parse --show-prefix 2>/dev/null)
    subdir=${subdir%/}

    local workdir=${PWD%/"$subdir"}
    workdir="${workdir/*\/}${subdir:+/$subdir}"

    gitsh_apply_color "$workdir" 'blue bold'
}

function gitsh_dirty {
    if ! git rev-parse --verify HEAD >/dev/null 2>&1
    then
        return 0
    fi

    local dirty_marker=' *'

    if ! git diff --quiet 2>/dev/null
    then
        gitsh_apply_color "$dirty_marker" red
    elif ! git diff --staged --quiet 2>/dev/null
    then
        gitsh_apply_color "$dirty_marker" yellow
    else
        return 0
    fi
}

function gitsh_dirty_stash {
    if ! git rev-parse --verify refs/stash >/dev/null 2>&1
    then
        return 0
    fi

    local dirty_stash_marker=' $'

    gitsh_apply_color "$dirty_stash_marker" red
}

declare -A gitsh_colors=(
    [blue bold]=$'\e[1;34m'
    [red]=$'\e[31m'
    [yellow bold]=$'\e[1;33m'
    [yellow reverse]=$'\e[7;33m'
    [yellow]=$'\e[33m'
)

function gitsh_apply_color {
    local ansi_reset=$'\001\e[m\002'

    local output=$1
    local color=$2

    color="\001${gitsh_colors[$color]}\002"

    echo -ne "${color}${output}${ansi_reset}"
}

function gitsh_prompt {
    gitsh_headname
    gitsh_upstream_state
    printf '!'
    gitsh_repo_state
    gitsh_workdir
    gitsh_dirty
    gitsh_dirty_stash
}

PS1='$(gitsh_prompt)> '

# This is referenced in `~/.bashrc`.
# shellcheck disable=2034
ADD_ON_PS1=$PS1
